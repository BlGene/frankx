<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Frankx: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Frankx
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">A High-Level Motion API for Franka</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Frankx Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div align="center"> <div class="image">
<img src="https://raw.githubusercontent.com/pantor/frankx/master/doc/logo.svg?sanitize=true" width="340"/>
</div>
 <h3 align="center">High-Level Motion Library for the Franka Panda Robot </h3>
</div><div align="center"> </div> <p><a href="https://github.com/pantor/frankx/actions"></a></p>
<p><a href="https://github.com/pantor/frankx/actions"></a></p>
<p><a href="https://github.com/pantor/frankx/issues"></a></p>
<p><a href="https://github.com/pantor/frankx/releases"></a></p>
<p><a href="https://github.com/pantor/frankx/blob/master/LICENSE"></a> </p>
<p>Frankx is a high-level motion library (both C++ and Python) for the Franka Emika Panda robot. It adds a Python wrapper around <a href="https://frankaemika.github.io/docs/libfranka.html">libfranka</a>, while replacing necessary real-time programming with higher-level motion commands. As frankx focuses on making real-time trajectory generation easy, it allows the robot to react to unforeseen events.</p>
<h2>Installation</h2>
<p>For using frankx with Python, you can start by </p><div class="fragment"><div class="line">pip install frankx</div></div><!-- fragment --><p>Frankx is based on <a href="https://github.com/frankaemika/libfranka">libfranka</a>, <a href="http://reflexxes.ws">Reflexxes</a> as a trajectory-generator, <a href="https://eigen.tuxfamily.org">Eigen</a> for transformation calculations and <a href="https://github.com/pybind/pybind11">pybind11</a> for the Python bindings. Make sure to have these dependencies installed, then you can build and install frankx via</p>
<div class="fragment"><div class="line">mkdir -p build</div><div class="line">cd build</div><div class="line">cmake -DReflexxes_ROOT_DIR=../RMLTypeII -DREFLEXXES_TYPE=ReflexxesTypeII -DBUILD_TYPE=Release ..</div><div class="line">make -j4</div><div class="line">make install</div></div><!-- fragment --><p>Of course, you need to adapt the Reflexxes directory and type (either <code>ReflexxesTypeII</code> or <code>ReflexxesTypeIV</code>). We strongly recommend Type IV, as the Panda robot is quite sensitive to acceleration discontinuities. To use frankx, you can also include it as a subproject in your parent CMake via <code>add_subdirectory(frankx)</code> and then <code>target_link_libraries(&lt;target&gt; libfrankx)</code>. Make sure that the built library can be found from Python by adapting your Python Path.</p>
<h2>Tutorial</h2>
<p>Frankx comes with both a C++ and Python API that differ only regarding real-time capability. We will introduce both languages next to each other. In your C++ project, just include <code>include &lt;<a class="el" href="frankx_8hpp.html">frankx/frankx.hpp</a>&gt;</code> and link the library. For Python, just <code>import frankx</code>. As a first example, only four lines of code are needed for simple robotic motions.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;frankx/frankx.hpp&gt;</div><div class="line">using namespace frankx;</div><div class="line"></div><div class="line">// Connect to the robot with the FCI IP address</div><div class="line">Robot robot(&quot;172.16.0.2&quot;);</div><div class="line"></div><div class="line">// Reduce velocity and acceleration of the robot</div><div class="line">robot.setDynamicRel(0.05);</div><div class="line"></div><div class="line">// Move the end-effector 20cm in positive x-direction</div><div class="line">auto motion = LinearRelativeMotion(Affine(0.2, 0.0, 0.0));</div><div class="line"></div><div class="line">// Finally move the robot</div><div class="line">robot.move(motion);</div></div><!-- fragment --><p>The corresponding program in Python is </p><div class="fragment"><div class="line">from frankx import Affine, LinearRelativeMotion, Robot</div><div class="line"></div><div class="line">robot = Robot(&quot;172.16.0.2&quot;)</div><div class="line">robot.set_dynamic_rel(0.05)</div><div class="line"></div><div class="line">motion = LinearRelativeMotion(Affine(0.2, 0.0, 0.0))</div><div class="line">robot.move(motion)</div></div><!-- fragment --><p>Furthermore, we will introduce methods for geometric calculations, for moving the robot according to different motion types, how to implement real-time reactions and changing waypoints in real time as well as controlling the gripper.</p>
<h3>Geometry</h3>
<p><code><a class="el" href="structfrankx_1_1_affine.html">frankx::Affine</a></code> is a thin wrapper around <a href="https://eigen.tuxfamily.org/dox/group__TutorialGeometry.html">Eigen::Affine3d</a>. It is used for Cartesian poses, frames and transformation. Frankx simplifies the usage of Euler angles (default ZYX-convention). </p><div class="fragment"><div class="line">{c++}</div><div class="line">// Initiliaze a transformation with an (x, y, z, a=0.0, b=0.0, c=0.0) translation</div><div class="line">Affine z_translation = Affine(0.0, 0.0, 0.5);</div><div class="line"></div><div class="line">// Define a rotation transformation using the (x, y, z, a, b, c) parameter list</div><div class="line">Affine z_rotation = Affine(0.0, 0.0, 0.0, M_PI / 3, 0.0, 0.0);</div><div class="line"></div><div class="line">// Make use of the wonderful Eigen library</div><div class="line">auto combined_transformation = z_translation * z_rotation;</div><div class="line"></div><div class="line">// Get the Euler angles (a, b, c) in a vector representation</div><div class="line">Eigen::Vector3d euler_angles = combined_transformation.angles();</div><div class="line"></div><div class="line">// Get the vector representation (x, y, z, a, b, c) of an affine transformation</div><div class="line">frankx::Vector6d pose = combined_transformation.vector();</div></div><!-- fragment --><p>In all cases, distances are in [m] and rotations in [rad]. Additionally, there are several helper functions for conversion between Eigen and libfranka's std::array objects. In python, this translates into </p><div class="fragment"><div class="line">z_translation = Affine(0.0, 0.0, 0.5)</div><div class="line">z_rotation = Affine(0.0, 0.0, 0.0, math.pi / 3, 0.0, 0.0)</div><div class="line">combined_transformation = z_translation * z_rotation</div><div class="line"></div><div class="line"># These two are now numpy arrays</div><div class="line">euler_angles = combined_transformation.angles()</div><div class="line">pose = combined_transformation.vector()</div></div><!-- fragment --><p>As the trajectory generation works in the Euler space, please make sure to have continuous Euler angles around your working point. You can adapt this by setting the flange to end-effector transformation via <code>setEE(...)</code>.</p>
<h3>Robot</h3>
<p>We wrapped most of the libfanka API (including the RobotState or ErrorMessage) for Python. Moreover, we added methods to adapt the dynamics of the robot for all motions. The <code>rel</code> name denotes that this a factor of the maximum constraints of the Panda robot. </p><div class="fragment"><div class="line">robot = Robot(&quot;172.16.0.2&quot;)</div><div class="line"></div><div class="line"># Recover from errors</div><div class="line">robot.recover_from_errors()</div><div class="line"></div><div class="line"># Set velocity, acceleration and jerk to 5% of the maximum</div><div class="line">robot.set_dynamic_rel(0.05)</div><div class="line"></div><div class="line"># Alternatively, you can define each constraint individually</div><div class="line">robot.velocity_rel = 0.2</div><div class="line">robot.acceleration_rel = 0.1</div><div class="line">robot.jerk_rel = 0.01</div></div><!-- fragment --><h3>Motion Types</h3>
<p>Frankx defines five different motion types. In python, you can use them as follows: </p><div class="fragment"><div class="line"># A point-to-point motion in the joint space</div><div class="line">m1 = JointMotion([-1.81194, 1.17910, 1.75710, -2.1416, -1.14336, 1.63304, -0.43217])</div><div class="line"></div><div class="line"># A linear motion in cartesian space</div><div class="line">m2 = LinearMotion(Affine(0.2, -0.4, 0.3, math.pi / 2, 0.0, 0.0))</div><div class="line">m3 = LinearMotion(Affine(0.2, -0.4, 0.3, math.pi / 2, 0.0, 0.0), elbow=1.7)  # With target elbow angle</div><div class="line"></div><div class="line"># A linear motion in cartesian space relative to the initial position</div><div class="line">m4 = LinearRelativeMotion(Affine(0.0, 0.1, 0.0))</div><div class="line"></div><div class="line"># A more complex motion by defining multiple waypoints</div><div class="line">m5 = WaypointMotion([</div><div class="line">  Waypoint(Affine(0.2, -0.4, 0.2, 0.3, 0.2, 0.1)),</div><div class="line">  # The following waypoint is relative to the prior one</div><div class="line">  Waypoint(Affine(0.0, 0.1, 0.0, Waypoint.ReferenceType.Relative))</div><div class="line">])</div><div class="line"></div><div class="line"># Hold the position for [s]</div><div class="line">m6 = PositionHold(5.0)</div></div><!-- fragment --><p>The real robot can be moved by applying a motion to the robot using <code>move</code>: </p><div class="fragment"><div class="line">robot.move(m1)</div><div class="line">robot.move(m2)</div><div class="line"></div><div class="line"># To use a given frame relative to the end effector</div><div class="line">camera_frame = Affine(0.1, 0.0, 0.1)</div><div class="line">robot.move(camera_frame, m3)</div><div class="line"></div><div class="line"># To change the dynamics of the motion, use MotionData</div><div class="line">data = MotionData(0.2)  # Using a dynamic_rel of 0.2 (eventually multiplied with robot.dynamic_rel)</div><div class="line">robot.move(m4, data)</div></div><!-- fragment --><p>Using MotionData, you can adapt the dynamics (velocity, acceleration and jerk) of a specific motion. </p><div class="fragment"><div class="line">data.velocity_rel = 1.0</div><div class="line">data.jerk_rel = 0.2</div></div><!-- fragment --><h3>Real-Time Reactions</h3>
<p>By adding reactions to the motion data, the robot can react to unforeseen events. In the Python API, you can define conditions by using a comparison between a robot's value and a given threshold. If the threshold is exceeded, the reaction fires. Following comparisons are currently implemented </p><div class="fragment"><div class="line">reaction_motion = LinearRelativeMotion(Affine(0.0, 0.0, 0.01))  # Move up for 1cm</div><div class="line"></div><div class="line"># Stop motion if the overall force is greater than 30N</div><div class="line">d1 = MotionData().with_reaction(Reaction(Measure.ForceXYZNorm() &gt; 30.0))</div><div class="line"></div><div class="line"># Apply reaction motion if the force in negative z-direction is greater than 10N</div><div class="line">d2 = MotionData().with_reaction(Reaction(Measure.ForceZ() &lt; -10.0), reaction_motion)</div><div class="line"></div><div class="line"># Stop motion if its duration is above 30s</div><div class="line">d3 = MotionData().with_reaction(Reaction(Measure.Time() &gt;= 30.0))</div><div class="line"></div><div class="line">robot.move(m2, d2)</div><div class="line"></div><div class="line"># Check if the reaction was triggered</div><div class="line">if d2.has_fired:</div><div class="line">  robot.recover_from_errors()</div><div class="line">  print(&#39;Force exceeded 10N!&#39;)</div></div><!-- fragment --><p>Once a reaction has fired, it will be neglected furthermore. In C++ you can additionally use lambdas to define more complex behaviours: </p><div class="fragment"><div class="line">{c++}</div><div class="line">// Stop motion if force is over 10N</div><div class="line">auto data = MotionData()</div><div class="line">  .withReaction({</div><div class="line">    Measure::ForceXYZNorm() &gt; 10.0  // [N]</div><div class="line">  })</div><div class="line">  .withReaction({</div><div class="line">    [](const franka::RobotState&amp; state, double time) {</div><div class="line">      return (state.current_errors.self_collision_avoidance_violation);</div><div class="line">    }</div><div class="line">  });</div><div class="line"></div><div class="line">// Hold position for 5s</div><div class="line">robot.move(PositionHold(5.0), data); // [s]</div><div class="line">// e.g. combined with a PositionHold, the robot continues its program after pushing the end effector.</div></div><!-- fragment --><h3>Real-Time Waypoint Motion</h3>
<p>While the robot moves in a background thread, you can change the waypoints in real-time. This is currently only possible from the C++ API. </p><div class="fragment"><div class="line">{c++}</div><div class="line">robot.moveAsync(motion_hold);</div><div class="line"></div><div class="line">// Wait for key input from user</div><div class="line">std::cin.get();</div><div class="line"></div><div class="line">motion_hold.setNextWaypoint(Waypoint(Affine(0.0, 0.0, 0.1), Waypoint::ReferenceType::Relative);</div></div><!-- fragment --><p>If you need this functionality using Python, feel free to make a pull request!</p>
<h3>Gripper</h3>
<p>In the <code><a class="el" href="classfrankx_1_1_gripper.html">frankx::Gripper</a></code> class, the default gripper force and gripper speed can be set. Then, additionally to the libfranka commands, the following helper methods can be used:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">auto gripper = Gripper(&quot;172.16.0.2&quot;);</div><div class="line"></div><div class="line">// These are the default values</div><div class="line">gripper.gripper_speed = 0.02; // [m/s]</div><div class="line">gripper.gripper_force = 20.0; // [N]</div><div class="line"></div><div class="line">// Preshape gripper before grasp, use the given speed</div><div class="line">gripper.move(50.0); // [mm]</div><div class="line"></div><div class="line">// Grasp an object of unknown width</div><div class="line">is_grasping = gripper.clamp();</div><div class="line"></div><div class="line">// Do something</div><div class="line">is_grasping &amp;= gripper.isGrasping();</div><div class="line"></div><div class="line">// Release an object and move to a given distance</div><div class="line">if (is_grasping) {</div><div class="line">  gripper.release(50.0);</div><div class="line">}</div></div><!-- fragment --><p>The Python API should be very straight-forward for the Gripper class.</p>
<h2>Documentation</h2>
<p>We will add a more detailed documentation once frankx reaches v1.0. However, you can find multiple examples for both C++ and Python in the <a href="https://github.com/pantor/frankx/tree/master/examples">examples</a> directory. We also try to add more examples over time.</p>
<h2>Development</h2>
<p>Frankx is written in C++17 and Python3. It is currently tested against following versions</p>
<ul>
<li>Python v3.7</li>
<li>Eigen v3.3.7</li>
<li>Libfranka v0.6.0</li>
<li>Reflexxes v1.2.7</li>
<li>Pybind11 v2.4.3</li>
<li>Catch2 v2.9 (only for testing)</li>
</ul>
<h2>License</h2>
<p>For non-commercial applications, this software is licensed under the LGPL v3.0. If you want to use frankx within commercial applications or under a different license, please contact us for individual agreements. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
